<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>esp1.fsr.compile documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">fsr</span> <span class="project-version">main</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>esp1</span></div></div></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>fsr</span></div></div></li><li class="depth-3 branch"><a href="esp1.fsr.cache.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>cache</span></div></a></li><li class="depth-3 branch current"><a href="esp1.fsr.compile.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>compile</span></div></a></li><li class="depth-3 branch"><a href="esp1.fsr.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-3 branch"><a href="esp1.fsr.ring.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ring</span></div></a></li><li class="depth-3"><a href="esp1.fsr.runtime.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>runtime</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="esp1.fsr.compile.html#var-*tracked-uris*"><div class="inner"><span>*tracked-uris*</span></div></a></li><li class="depth-1"><a href="esp1.fsr.compile.html#var-classify-route"><div class="inner"><span>classify-route</span></div></a></li><li class="depth-1"><a href="esp1.fsr.compile.html#var-compile-dynamic-routes"><div class="inner"><span>compile-dynamic-routes</span></div></a></li><li class="depth-1"><a href="esp1.fsr.compile.html#var-compile-static-html"><div class="inner"><span>compile-static-html</span></div></a></li><li class="depth-1"><a href="esp1.fsr.compile.html#var-discover-dynamic-routes"><div class="inner"><span>discover-dynamic-routes</span></div></a></li><li class="depth-1"><a href="esp1.fsr.compile.html#var-publish"><div class="inner"><span>publish</span></div></a></li><li class="depth-1"><a href="esp1.fsr.compile.html#var-track-uri"><div class="inner"><span>track-uri</span></div></a></li><li class="depth-1"><a href="esp1.fsr.compile.html#var-write-compiled-routes"><div class="inner"><span>write-compiled-routes</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">esp1.fsr.compile</h1><div class="doc"><div class="markdown"><p>Build-time route compilation for production deployment.</p>
<h2><a href="#architecture" id="architecture"></a>Architecture</h2>
<pre><code>Build Time:  Filesystem → Discover routes → Classify → Compile → Write EDN
Runtime:     Request → Load EDN (once) → Match → Resolve handler → Execute
</code></pre>
<h2><a href="#what-gets-compiled" id="what-gets-compiled"></a>What Gets Compiled</h2>
<ul>
<li><strong>GET routes</strong> → Static HTML files via <code>compile-static-html</code></li>
<li><strong>Non-GET routes</strong> → Compiled route data via <code>compile-dynamic-routes</code></li>
</ul>
<h2><a href="#compiled-route-format" id="compiled-route-format"></a>Compiled Route Format</h2>
<p>Routes are compiled into two categories for efficient runtime matching:</p>
<ul>
<li><strong>Static routes</strong>: Fixed URIs (e.g., <code>/api/users</code>) → O(1) hash lookup</li>
<li><strong>Pattern routes</strong>: Parameterized URIs (e.g., <code>/thing/&lt;id&gt;</code>) → O(n) regex matching</li>
</ul>
<h2><a href="#main-entry-point" id="main-entry-point"></a>Main Entry Point</h2>
<p>Use <code>publish</code> for complete production builds:</p>
<pre><code class="language-clojure">(publish {:root-fs-path "src/routes"
          :publish-dir "dist"})
</code></pre>
<p>See <code>esp1.fsr.runtime</code> for loading and matching compiled routes.</p>
</div></div><div class="public anchor" id="var-*tracked-uris*"><h3>*tracked-uris*</h3><h4 class="dynamic">dynamic</h4><div class="usage"></div><div class="doc"><div class="markdown"><p>Dynamically bound atom to hold tracked URIs during static compilation. Used by <code>track-uri</code> to collect parameterized URIs for generation.</p>
</div></div><div class="src-link"><a href="https://github.com/esp1/fsr/blob/main/src/esp1/fsr/compile.clj#L46">view source</a></div></div><div class="public anchor" id="var-classify-route"><h3>classify-route</h3><div class="usage"><code>(classify-route route-meta)</code></div><div class="doc"><div class="markdown"><p>Classifies a route as :static or :pattern based on its URI template.</p>
<ul>
<li>:static - No path parameters (e.g. “/api/users”)</li>
<li>:pattern - Contains <param></param> or «param» (e.g. “/thing/<id>”)</id></li>
</ul>
<p>Returns the route metadata with added :route-type key.</p>
</div></div><div class="src-link"><a href="https://github.com/esp1/fsr/blob/main/src/esp1/fsr/compile.clj#L183">view source</a></div></div><div class="public anchor" id="var-compile-dynamic-routes"><h3>compile-dynamic-routes</h3><div class="usage"><code>(compile-dynamic-routes root-fs-path)</code></div><div class="doc"><div class="markdown"><p>Compiles non-GET routes into runtime-efficient data structures.</p>
<p>Scans root-fs-path, discovers non-GET routes (POST/PUT/DELETE/etc.), classifies them as static or pattern, and compiles into efficient data structures for runtime matching.</p>
<p>Returns:</p>
<pre><code class="language-clojure">{:static-routes {"api/users" {:methods {:post {...} :delete {...}}}}
 :pattern-routes [{:pattern "^thing/([^/]+)$" :param-names ["id"] ...}]}
</code></pre>
</div></div><div class="src-link"><a href="https://github.com/esp1/fsr/blob/main/src/esp1/fsr/compile.clj#L278">view source</a></div></div><div class="public anchor" id="var-compile-static-html"><h3>compile-static-html</h3><div class="usage"><code>(compile-static-html root-fs-path publish-dir)</code></div><div class="doc"><div class="markdown"><p>Compiles GET routes to static HTML files.</p>
<p>Finds all GET endpoint functions in root-fs-path, invokes them, and writes their responses to HTML files in publish-dir.</p>
<p>Handles two types of routes: 1. Non-parameterized routes (e.g., /about) - generated automatically 2. Parameterized routes (e.g., /blog/<id>) - must be tracked via <code>track-uri</code></id></p>
<p>Example:</p>
<pre><code class="language-clojure">(compile-static-html "src/routes" "dist")
</code></pre>
</div></div><div class="src-link"><a href="https://github.com/esp1/fsr/blob/main/src/esp1/fsr/compile.clj#L97">view source</a></div></div><div class="public anchor" id="var-discover-dynamic-routes"><h3>discover-dynamic-routes</h3><div class="usage"><code>(discover-dynamic-routes root-fs-path)</code></div><div class="doc"><div class="markdown"><p>Scans root-fs-path and returns all route metadata for non-GET routes.</p>
<p>Returns a sequence of route metadata maps, each containing: - :uri - The URI template (e.g. “/foo” or “/thing/<id>”) - :file - The java.io.File for the route - :ns-sym - The namespace symbol - :endpoint-meta - Full namespace metadata map</id></p>
<p>Only includes routes with :endpoint/http metadata containing non-GET methods.</p>
</div></div><div class="src-link"><a href="https://github.com/esp1/fsr/blob/main/src/esp1/fsr/compile.clj#L153">view source</a></div></div><div class="public anchor" id="var-publish"><h3>publish</h3><div class="usage"><code>(publish {:keys [root-fs-path publish-dir compile-routes? compiled-routes-file], :or {compile-routes? true}})</code></div><div class="doc"><div class="markdown"><p>Unified publishing function for production deployment.</p>
<p>Generates both static HTML files (for GET routes) and compiled route data (for non-GET routes). This is the recommended function for production builds.</p>
<p>Options map: - :root-fs-path - Source directory containing route files (required) - :publish-dir - Output directory for generated files (required) - :compile-routes? - Enable route compilation for non-GET methods (default: true) - :compiled-routes-file - Output file for compiled routes (default: publish-dir/compiled-routes.edn)</p>
<p>Returns a map with: - :static-files-generated - Number of static HTML files generated - :compiled-routes-file - Path to compiled routes file (if enabled) - :static-routes-count - Number of static routes compiled - :pattern-routes-count - Number of pattern routes compiled</p>
<p>Example:</p>
<pre><code class="language-clojure">(publish {:root-fs-path "src/my_app/routes"
          :publish-dir "dist"
          :compile-routes? true})
</code></pre>
</div></div><div class="src-link"><a href="https://github.com/esp1/fsr/blob/main/src/esp1/fsr/compile.clj#L315">view source</a></div></div><div class="public anchor" id="var-track-uri"><h3>track-uri</h3><div class="usage"><code>(track-uri uri)</code></div><div class="doc"><div class="markdown"><p>Tracks a URI for static HTML generation.</p>
<p>During static compilation, dynamically constructed URIs (e.g., blog post links) can be tracked so they are included in the generated output.</p>
<p>Returns the unchanged URI, allowing inline use:</p>
<pre><code class="language-clojure">[:a {:href (track-uri (str "/blog/" post-id))} "Read More"]
</code></pre>
</div></div><div class="src-link"><a href="https://github.com/esp1/fsr/blob/main/src/esp1/fsr/compile.clj#L51">view source</a></div></div><div class="public anchor" id="var-write-compiled-routes"><h3>write-compiled-routes</h3><div class="usage"><code>(write-compiled-routes compiled-routes output-path)</code></div><div class="doc"><div class="markdown"><p>Writes compiled routes to an EDN file.</p>
<p>Args: - compiled-routes: Result from compile-routes - output-path: File path for output (e.g. “dist/compiled-routes.edn”)</p>
</div></div><div class="src-link"><a href="https://github.com/esp1/fsr/blob/main/src/esp1/fsr/compile.clj#L303">view source</a></div></div></div></body></html>